import heapq

goal = [(1,2,3),(4,5,6),(7,8,0)]
moves = [(-1,0),(1,0),(0,-1),(0,1)]

def manhattan(p): return sum(abs((v-1)//3 - i) + abs((v-1)%3 - j) for i,r in enumerate(p) for j,v in enumerate(r) if v)
def find_zero(p): return next((i,j) for i in range(3) for j in range(3) if p[i][j]==0)
def neighbors(p):
    i,j = find_zero(p)
    for dx,dy in moves:
        x,y = i+dx, j+dy
        if 0<=x<3 and 0<=y<3:
            q = [list(r) for r in p]
            q[i][j], q[x][y] = q[x][y], q[i][j]
            yield tuple(map(tuple, q))

def solve(start):
    pq, seen = [(manhattan(start), 0, start, [])], set()
    while pq:
        _, g, state, path = heapq.heappop(pq)
        if state == goal: return path + [state]
        if state in seen: continue
        seen.add(state)
        for n in neighbors(state):
            heapq.heappush(pq, (g+1+manhattan(n), g+1, n, path+[state]))

start = ((2,8,3),(1,6,4),(7,0,5))
for s in solve(start): [print(row) for row in s], print("-----")
